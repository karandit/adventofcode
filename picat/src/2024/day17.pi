import util, sat.

main([File]) =>
    Lines = read_file_lines(File),
    [LA, LB, LC, _, LP] = Lines,
    [RA, RB, RC] = [to_int(R): [_,R] in [split(L, ":"): L in [LA, LB, LC]]],
    [_, LProg] = split(LP,":"),
    ProgL = [to_int(P): P in split(LProg, ",")],
    Prog = to_array(ProgL),
    LenProg = len(Prog),

    Rs = {1, (RA, RB, RC), []},
    while (Rs[1] < LenProg)
      Rs := exec(Prog[Rs[1]], Prog[Rs[1]+1], Rs),
    end,
    {_, _, Out} = Rs,
    printf("Part1: %w; ", Out.reverse.map(to_string).join(",")),

    gen(A, [2,4,1,1,7,5, 1,4,0,3,4,5, 5,5,3,0]),
    solve($[min(A)], A),
    printf("Part2: %w%n", A).

combo(X, _) = X, X<=3 => true.
combo(4, (A,_,_)) = A.
combo(5, (_,B,_)) = B.
combo(6, (_,_,C)) = C.

exec(0, Op, {IP, Rs@(A, B, C), Out}) = {IP + 2, (A // (2  ** combo(Op, Rs)), B, C), Out}.
exec(1, Op, {IP, Rs@(A, B, C), Out}) = {IP + 2, (A, B ^ Op, C), Out}.
exec(2, Op, {IP, Rs@(A, B, C), Out}) = {IP + 2, (A, combo(Op, Rs) mod 8, C), Out}.
exec(3, Op, {IP, Rs@(0, B, C), Out}) = {IP + 2, Rs, Out}.
exec(3, Op, {IP, Rs@(A, B, C), Out}) = {Op + 1, Rs, Out}.
exec(4, Op, {IP, Rs@(A, B, C), Out}) = {IP + 2, (A, B ^ C, C), Out}.
exec(5, Op, {IP, Rs@(A, B, C), Out}) = {IP + 2, Rs, [combo(Op, Rs) mod 8| Out]}.
exec(6, Op, {IP, Rs@(A, B, C), Out}) = {IP + 2, (A, A // (2  ** combo(Op, Rs)), C), Out}.
exec(7, Op, {IP, Rs@(A, B, C), Out}) = {IP + 2, (A, B, A // (2  ** combo(Op, Rs))), Out}.

/* the program is the same as the output
2,4,  B = A mod 8
1,1,  B = B^1
7,5,  C = A/2**B
1,4,  B = B^4
0,3,  A = A/2**3
4,0,  B = B ^ C
5,5,  out B mod 8
3,0
*/

% use constraints to generate possible candidates for A
gen(A,[]) => A = 0.  % halt after A=0
gen(A,[Z|Zs]) =>
    VA = new_array(56),    % A's binary representation
    VA :: 0..1,
    A #= sum([2**(K-1)*VA[K] : K in 1..56]),
% 2,4,  B = A mod 8
%    B1 #= VA[1]+ 2*VA[2]+ 4*VA[3],
% 1,1,  B = B^1
    VB2 = new_array(56),
    foreach (I in 4..56) VB2[I] = 0 end,
    VB2 :: 0..1,
    VB2[1] #= 1-VA[1],
    VB2[2] #= VA[2],
    VB2[3] #= VA[3],
    B2 #= (1-VA[1]) + 2*VA[2] + 4*VA[3],
% 7,5,  C = A/2**B
    C1 #= A div (2**B2),
    VC1 = new_array(56),
    VC1 :: 0..1,
    C1 #= sum([2**(K-1)*VC1[K] : K in 1..56]),
% 1,4,  B = B ^ 4
    VB3 = new_array(56),
    foreach (I in 4..56) VB3[I] = VB2[I] end,
    VB3 :: 0..1,
    VB3[1] #= VB2[1],
    VB3[2] #= VB2[2],
    VB3[3] #= (#~VB2[3]),
% 0,3,  A = A/2**3
    A2 #= sum([2**(K-4)*VA[K] : K in 4..56]),
% 4,0,  B = B ^ C
    VB4 = new_array(56),
    VB4 :: 0..1,
    foreach (I in 1..56)
        VB4[I] #= VB3[I] #^ VC1[I]
    end,
    B4 #= sum([2**(K-1)*VB4[K] : K in 1..56]),
% 5,5,  out B mod 8
    Z #= B4 mod 8,
    gen(A2,Zs).
